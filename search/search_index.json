{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Punq","text":"<p>An unintrusive library for dependency injection in modern Python. Inspired by Funq, Punq is a dependency injection library you can understand.</p> <ul> <li>No global state</li> <li>No decorators</li> <li>No weird syntax applied to arguments</li> <li>Small and simple code base with 100% test coverage and developer-friendly comments.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Punq is available on the cheese shop</p> <pre><code>pip install punq\n</code></pre> <p>Documentation is available on Github pages.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Punq avoids global state, so you must explicitly create a container in the entrypoint of your application:</p> <pre><code>import punq\n\ncontainer = punq.Container()\n</code></pre> <p>Once you have a container, you can register your application's dependencies. In the simplest case, we can register any arbitrary object with some key:</p> <pre><code>container.register(\"connection_string\", instance=\"postgresql://...\")\n</code></pre> <p>We can then request that object back from the container:</p> <pre><code>conn_str = container.resolve(\"connection_string\")\n</code></pre> <p>Usually, though, we want to register some object that implements a useful service.:</p> <pre><code>class ConfigReader:\n    def get_config(self):\n        pass\n\nclass EnvironmentConfigReader(ConfigReader):\n    def get_config(self):\n        return {\n        \"logging\": {\n            \"level\": os.env.get(\"LOGGING_LEVEL\", \"debug\")\n        },\n        \"greeting\": os.env.get(\"GREETING\", \"Hello world\")\n        }\n\ncontainer.register(ConfigReader, EnvironmentConfigReader)\n</code></pre> <p>Now we can <code>resolve</code> the <code>ConfigReader</code> service, and receive a concrete implementation:</p> <pre><code>config = container.resolve(ConfigReader).get_config()\n</code></pre> <p>If our application's dependencies have their own dependencies, Punq will inject those, too:</p> <pre><code>class Greeter:\n    def greet(self):\n        pass\n\n\nclass ConsoleGreeter(Greeter):\n    def __init__(self, config_reader: ConfigReader):\n        self.config = config_reader.get_config()\n\n    def greet(self):\n        print(self.config['greeting'])\n\n\ncontainer.register(Greeter, ConsoleGreeter)\ncontainer.resolve(Greeter).greet()\n</code></pre> <p>If you just want to resolve an object without having any base class, that's okay:</p> <pre><code>class Greeter:\n    def __init__(self, config_reader: ConfigReader):\n        self.config = config_reader.get_config()\n\n    def greet(self):\n        print(self.config['greeting'])\n\ncontainer.register(Greeter)\ncontainer.resolve(Greeter).greet()\n</code></pre> <p>And if you need to have a singleton object for some reason, we can tell punq to register a specific instance of an object:</p> <pre><code>class FileWritingGreeter:\n    def __init__(self, path, greeting):\n        self.path = path\n        self.message = greeting\n        self.file = open(self.path, 'w')\n\n    def greet(self):\n        self.file.write(self.message)\n\n\none_true_greeter = FileWritingGreeter(\"/tmp/greetings\", \"Hello world\")\ncontainer.register(Greeter, instance=one_true_greeter)\n</code></pre> <p>You might not know all of your arguments at registration time, but you can provide them later:</p> <pre><code>container.register(Greeter, FileWritingGreeter)\ngreeter = container.resolve(Greeter, path=\"/tmp/foo\", greeting=\"Hello world\")\n</code></pre> <p>Conversely, you might want to provide arguments at registration time, without adding them to the container:</p> <pre><code>container.register(Greeter, FileWritingGreeter, path=\"/tmp/foo\", greeting=\"Hello world\")\n</code></pre>"},{"location":"modules/","title":"Modules","text":"<p>Simple IOC container.</p> <p>Classes:</p> <pre><code>Container\nMissingDependencyError\nInvalidRegistrationError\nInvalidForwardReferenceError\nMissingDependencyException\nInvalidRegistrationException\nInvalidForwardReferenceException\nScope\n</code></pre> <p>Misc Variables:</p> <pre><code>empty\n</code></pre>"},{"location":"modules/#punq.Container","title":"<code>Container</code>","text":"<p>Provides dependency registration and resolution.</p> <p>This is the main entrypoint of the Punq library. In normal scenarios users will only need to interact with this class.</p> Source code in <code>punq/__init__.py</code> <pre><code>class Container:\n    \"\"\"Provides dependency registration and resolution.\n\n    This is the main entrypoint of the Punq library. In normal scenarios users\n    will only need to interact with this class.\n    \"\"\"\n\n    def __init__(self, registrations=None, auto_register=False):\n        self.registrations = _Registry(registrations)\n        self.register(Container, instance=self)\n        self._singletons = {}\n        self._auto_register = auto_register\n\n    def register(self, service, factory=empty, instance=empty, scope=Scope.transient, **kwargs):\n        \"\"\"Register a dependency into the container.\n\n        Each registration in Punq has a \"service\", which is the key used for\n        resolving dependencies, and either an \"instance\" that implements the\n        service or a \"factory\" that understands how to create an instance on\n        demand.\n\n        Examples:\n            If we have an object that is expensive to construct, or that\n            wraps a resouce that must not be shared, we might choose to\n            use a singleton instance.\n\n            &gt;&gt;&gt; import sqlalchemy\n            &gt;&gt;&gt; from punq import Container\n            &gt;&gt;&gt; container = Container()\n\n            &gt;&gt;&gt; class DataAccessLayer:\n            ...     pass\n            ...\n            &gt;&gt;&gt; class SqlAlchemyDataAccessLayer(DataAccessLayer):\n            ...     def __init__(self, engine: sqlalchemy.engine.Engine):\n            ...         pass\n            ...\n            &gt;&gt;&gt; dal = SqlAlchemyDataAccessLayer(sqlalchemy.create_engine(\"sqlite:///\"))\n            &gt;&gt;&gt; container.register(\n            ...     DataAccessLayer,\n            ...     instance=dal\n            ... )\n            &lt;punq.Container object at 0x...&gt;\n            &gt;&gt;&gt; assert container.resolve(DataAccessLayer) is dal\n\n            If we need to register a dependency, but we don't need to\n                abstract it, we can register it as concrete.\n\n            &gt;&gt;&gt; class FileReader:\n            ...     def read (self):\n            ...         # Assorted legerdemain and rigmarole\n            ...         pass\n            ...\n            &gt;&gt;&gt; container.register(FileReader)\n            &lt;punq.Container object at 0x...&gt;\n            &gt;&gt;&gt; assert type(container.resolve(FileReader)) == FileReader\n\n            In this example, the EmailSender type is an abstract class\n            and SmtpEmailSender is our concrete implementation.\n\n            &gt;&gt;&gt; class EmailSender:\n            ...     def send(self, msg):\n            ...         pass\n            ...\n            &gt;&gt;&gt; class SmtpEmailSender (EmailSender):\n            ...     def send(self, msg):\n            ...         print(\"Sending message via smtp\")\n            ...\n            &gt;&gt;&gt; container.register(EmailSender, SmtpEmailSender)\n            &lt;punq.Container object at 0x...&gt;\n            &gt;&gt;&gt; instance = container.resolve(EmailSender)\n            &gt;&gt;&gt; instance.send(\"beep\")\n            Sending message via smtp\n        \"\"\"\n        self.registrations.register(service, factory, instance, scope, **kwargs)\n        return self\n\n    def resolve_all(self, service, **kwargs):\n        \"\"\"Return all registrations for a given service.\n\n        Some patterns require us to use multiple implementations of an\n        interface at the same time.\n\n        Examples:\n            In this example, we want to use multiple Authenticator instances to\n            check a request.\n\n            &gt;&gt;&gt; class Authenticator:\n            ...     def matches(self, req):\n            ...         return False\n            ...\n            ...     def authenticate(self, req):\n            ...         return False\n            ...\n            &gt;&gt;&gt; class BasicAuthenticator(Authenticator):\n            ...     def matches(self, req):\n            ...         head = req.headers.get(\"Authorization\", \"\")\n            ...         return head.startswith(\"Basic \")\n            ...\n            &gt;&gt;&gt; class TokenAuthenticator(Authenticator):\n            ...     def matches(self, req):\n            ...         head = req.headers.get(\"Authorization\", \"\")\n            ...         return head.startswith(\"Bearer \")\n            ...\n            &gt;&gt;&gt; def authenticate_request(container, req):\n            ...     for authn in req.resolve_all(Authenticator):\n            ...         if authn.matches(req):\n            ...             return authn.authenticate(req)\n        \"\"\"\n        context = self.registrations.build_context(service)\n\n        return [self._build_impl(x, kwargs, context) for x in context.all_registrations(service)]\n\n    def _build_impl(self, registration, resolution_args, context):\n        \"\"\"Instantiate the registered service.\"\"\"\n        spec = inspect.getfullargspec(registration.builder)\n        target_args = spec.args + spec.kwonlyargs\n\n        args = _match_defaults(spec)\n        args.update({\n            k: self._resolve_impl(v, resolution_args, context, args.get(k))\n            for k, v in registration.needs.items()\n            if k != \"return\" and k not in registration.args and k not in resolution_args\n        })\n        args.update(registration.args)\n\n        if \"self\" in target_args:\n            target_args.remove(\"self\")\n        condensed_resolution_args = {key: resolution_args[key] for key in resolution_args if key in target_args}\n        args.update(condensed_resolution_args or {})\n\n        result = registration.builder(**args)\n\n        if registration.scope == Scope.singleton:\n            self._singletons[registration.service] = result\n\n        context[registration.service] = result\n\n        return result\n\n    def _should_auto_register(self, service_key, registration):\n        if self._auto_register is False:\n            return False\n        return registration is None and inspect.isclass(service_key)\n\n    def _resolve_impl(self, service_key, kwargs, context, default=None):\n        context = self.registrations.build_context(service_key, context)\n\n        if service_key in self._singletons:\n            return self._singletons[service_key]\n\n        if context.has_cached(service_key):\n            return context[service_key]\n\n        target = context.target(service_key)\n\n        if target.is_generic_list():\n            return self.resolve_all(target.generic_parameter)\n\n        registration = target.next_impl()\n\n        if registration is None and default is not None:\n            return default\n\n        if self._should_auto_register(service_key, registration):\n            self.registrations.register_concrete_service(service_key, Scope.transient)\n            return self._resolve_impl(service_key, kwargs, None, default)\n\n        if registration is None:\n            raise MissingDependencyError(\"Failed to resolve implementation for \" + str(service_key))\n\n        return self._build_impl(registration, kwargs, context)\n\n    def resolve(self, service_key, **kwargs):\n        \"\"\"Build and return an instance of a registered service.\"\"\"\n        context = self.registrations.build_context(service_key)\n\n        return self._resolve_impl(service_key, kwargs, context)\n\n    def instantiate(self, service_key, **kwargs):\n        \"\"\"Instantiate an unregistered service.\"\"\"\n        registration = _Registration(\n            service_key,\n            Scope.transient,\n            service_key,\n            self.registrations._get_needs_for_ctor(service_key),\n            {},\n        )\n\n        context = _ResolutionContext(service_key, [registration])\n\n        return self._build_impl(registration, kwargs, context)\n\n    def child(self):\n        \"\"\"Create a new container that inherits configuration from this one.\n\n        You may need to change dependencies for a particular scope of your\n        system, for example, to override them in tests, or to add per-request\n        data.\n\n        Punq supports \"child\" containers for this purpose.\n\n        Examples:\n            In this example, we want to register a per-request dependency into\n            our child container. Each child will resolve its own instance of\n            the RequestData.\n            The order of registration is unimportant.\n\n            &gt;&gt;&gt; from collections import namedtuple\n\n            &gt;&gt;&gt; RequestData = namedtuple('RequestData', 'user_id is_admin')\n\n            &gt;&gt;&gt; class RequestHandler:\n            ...\n            ...     def __init__(self, state: RequestData):\n            ...         self.state= state\n            ...\n            ...     def handle(self) -&gt; None:\n            ...         print(self.state)\n            ...\n\n            &gt;&gt;&gt; app_container = Container()\n\n            &gt;&gt;&gt; first_request_container = app_container.child()\n            &gt;&gt;&gt; second_request_container = app_container.child()\n\n            &gt;&gt;&gt; first_request_container.register(RequestData, instance=RequestData(123, True))\n            &lt;punq.Container object at 0x...&gt;\n\n            &gt;&gt;&gt; second_request_container.register(RequestData, instance=RequestData(789, False))\n            &lt;punq.Container object at 0x...&gt;\n\n            &gt;&gt;&gt; app_container.register(RequestHandler)\n            &lt;punq.Container object at 0x...&gt;\n\n            &gt;&gt;&gt; first_request_container.resolve(RequestHandler).handle()\n            RequestData(user_id=123, is_admin=True)\n\n            &gt;&gt;&gt; second_request_container.resolve(RequestHandler).handle()\n            RequestData(user_id=789, is_admin=False)\n        \"\"\"\n        return Container(self.registrations, auto_register=self._auto_register)\n</code></pre>"},{"location":"modules/#punq.Container.child","title":"<code>child()</code>","text":"<p>Create a new container that inherits configuration from this one.</p> <p>You may need to change dependencies for a particular scope of your system, for example, to override them in tests, or to add per-request data.</p> <p>Punq supports \"child\" containers for this purpose.</p> <p>Examples:</p> <p>In this example, we want to register a per-request dependency into our child container. Each child will resolve its own instance of the RequestData. The order of registration is unimportant.</p> <pre><code>&gt;&gt;&gt; from collections import namedtuple\n</code></pre> <pre><code>&gt;&gt;&gt; RequestData = namedtuple('RequestData', 'user_id is_admin')\n</code></pre> <pre><code>&gt;&gt;&gt; class RequestHandler:\n...\n...     def __init__(self, state: RequestData):\n...         self.state= state\n...\n...     def handle(self) -&gt; None:\n...         print(self.state)\n...\n</code></pre> <pre><code>&gt;&gt;&gt; app_container = Container()\n</code></pre> <pre><code>&gt;&gt;&gt; first_request_container = app_container.child()\n&gt;&gt;&gt; second_request_container = app_container.child()\n</code></pre> <pre><code>&gt;&gt;&gt; first_request_container.register(RequestData, instance=RequestData(123, True))\n&lt;punq.Container object at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; second_request_container.register(RequestData, instance=RequestData(789, False))\n&lt;punq.Container object at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; app_container.register(RequestHandler)\n&lt;punq.Container object at 0x...&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; first_request_container.resolve(RequestHandler).handle()\nRequestData(user_id=123, is_admin=True)\n</code></pre> <pre><code>&gt;&gt;&gt; second_request_container.resolve(RequestHandler).handle()\nRequestData(user_id=789, is_admin=False)\n</code></pre> Source code in <code>punq/__init__.py</code> <pre><code>def child(self):\n    \"\"\"Create a new container that inherits configuration from this one.\n\n    You may need to change dependencies for a particular scope of your\n    system, for example, to override them in tests, or to add per-request\n    data.\n\n    Punq supports \"child\" containers for this purpose.\n\n    Examples:\n        In this example, we want to register a per-request dependency into\n        our child container. Each child will resolve its own instance of\n        the RequestData.\n        The order of registration is unimportant.\n\n        &gt;&gt;&gt; from collections import namedtuple\n\n        &gt;&gt;&gt; RequestData = namedtuple('RequestData', 'user_id is_admin')\n\n        &gt;&gt;&gt; class RequestHandler:\n        ...\n        ...     def __init__(self, state: RequestData):\n        ...         self.state= state\n        ...\n        ...     def handle(self) -&gt; None:\n        ...         print(self.state)\n        ...\n\n        &gt;&gt;&gt; app_container = Container()\n\n        &gt;&gt;&gt; first_request_container = app_container.child()\n        &gt;&gt;&gt; second_request_container = app_container.child()\n\n        &gt;&gt;&gt; first_request_container.register(RequestData, instance=RequestData(123, True))\n        &lt;punq.Container object at 0x...&gt;\n\n        &gt;&gt;&gt; second_request_container.register(RequestData, instance=RequestData(789, False))\n        &lt;punq.Container object at 0x...&gt;\n\n        &gt;&gt;&gt; app_container.register(RequestHandler)\n        &lt;punq.Container object at 0x...&gt;\n\n        &gt;&gt;&gt; first_request_container.resolve(RequestHandler).handle()\n        RequestData(user_id=123, is_admin=True)\n\n        &gt;&gt;&gt; second_request_container.resolve(RequestHandler).handle()\n        RequestData(user_id=789, is_admin=False)\n    \"\"\"\n    return Container(self.registrations, auto_register=self._auto_register)\n</code></pre>"},{"location":"modules/#punq.Container.instantiate","title":"<code>instantiate(service_key, **kwargs)</code>","text":"<p>Instantiate an unregistered service.</p> Source code in <code>punq/__init__.py</code> <pre><code>def instantiate(self, service_key, **kwargs):\n    \"\"\"Instantiate an unregistered service.\"\"\"\n    registration = _Registration(\n        service_key,\n        Scope.transient,\n        service_key,\n        self.registrations._get_needs_for_ctor(service_key),\n        {},\n    )\n\n    context = _ResolutionContext(service_key, [registration])\n\n    return self._build_impl(registration, kwargs, context)\n</code></pre>"},{"location":"modules/#punq.Container.register","title":"<code>register(service, factory=empty, instance=empty, scope=Scope.transient, **kwargs)</code>","text":"<p>Register a dependency into the container.</p> <p>Each registration in Punq has a \"service\", which is the key used for resolving dependencies, and either an \"instance\" that implements the service or a \"factory\" that understands how to create an instance on demand.</p> <p>Examples:</p> <p>If we have an object that is expensive to construct, or that wraps a resouce that must not be shared, we might choose to use a singleton instance.</p> <pre><code>&gt;&gt;&gt; import sqlalchemy\n&gt;&gt;&gt; from punq import Container\n&gt;&gt;&gt; container = Container()\n</code></pre> <pre><code>&gt;&gt;&gt; class DataAccessLayer:\n...     pass\n...\n&gt;&gt;&gt; class SqlAlchemyDataAccessLayer(DataAccessLayer):\n...     def __init__(self, engine: sqlalchemy.engine.Engine):\n...         pass\n...\n&gt;&gt;&gt; dal = SqlAlchemyDataAccessLayer(sqlalchemy.create_engine(\"sqlite:///\"))\n&gt;&gt;&gt; container.register(\n...     DataAccessLayer,\n...     instance=dal\n... )\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; assert container.resolve(DataAccessLayer) is dal\n</code></pre> <p>If we need to register a dependency, but we don't need to     abstract it, we can register it as concrete.</p> <pre><code>&gt;&gt;&gt; class FileReader:\n...     def read (self):\n...         # Assorted legerdemain and rigmarole\n...         pass\n...\n&gt;&gt;&gt; container.register(FileReader)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; assert type(container.resolve(FileReader)) == FileReader\n</code></pre> <p>In this example, the EmailSender type is an abstract class and SmtpEmailSender is our concrete implementation.</p> <pre><code>&gt;&gt;&gt; class EmailSender:\n...     def send(self, msg):\n...         pass\n...\n&gt;&gt;&gt; class SmtpEmailSender (EmailSender):\n...     def send(self, msg):\n...         print(\"Sending message via smtp\")\n...\n&gt;&gt;&gt; container.register(EmailSender, SmtpEmailSender)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; instance = container.resolve(EmailSender)\n&gt;&gt;&gt; instance.send(\"beep\")\nSending message via smtp\n</code></pre> Source code in <code>punq/__init__.py</code> <pre><code>def register(self, service, factory=empty, instance=empty, scope=Scope.transient, **kwargs):\n    \"\"\"Register a dependency into the container.\n\n    Each registration in Punq has a \"service\", which is the key used for\n    resolving dependencies, and either an \"instance\" that implements the\n    service or a \"factory\" that understands how to create an instance on\n    demand.\n\n    Examples:\n        If we have an object that is expensive to construct, or that\n        wraps a resouce that must not be shared, we might choose to\n        use a singleton instance.\n\n        &gt;&gt;&gt; import sqlalchemy\n        &gt;&gt;&gt; from punq import Container\n        &gt;&gt;&gt; container = Container()\n\n        &gt;&gt;&gt; class DataAccessLayer:\n        ...     pass\n        ...\n        &gt;&gt;&gt; class SqlAlchemyDataAccessLayer(DataAccessLayer):\n        ...     def __init__(self, engine: sqlalchemy.engine.Engine):\n        ...         pass\n        ...\n        &gt;&gt;&gt; dal = SqlAlchemyDataAccessLayer(sqlalchemy.create_engine(\"sqlite:///\"))\n        &gt;&gt;&gt; container.register(\n        ...     DataAccessLayer,\n        ...     instance=dal\n        ... )\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; assert container.resolve(DataAccessLayer) is dal\n\n        If we need to register a dependency, but we don't need to\n            abstract it, we can register it as concrete.\n\n        &gt;&gt;&gt; class FileReader:\n        ...     def read (self):\n        ...         # Assorted legerdemain and rigmarole\n        ...         pass\n        ...\n        &gt;&gt;&gt; container.register(FileReader)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; assert type(container.resolve(FileReader)) == FileReader\n\n        In this example, the EmailSender type is an abstract class\n        and SmtpEmailSender is our concrete implementation.\n\n        &gt;&gt;&gt; class EmailSender:\n        ...     def send(self, msg):\n        ...         pass\n        ...\n        &gt;&gt;&gt; class SmtpEmailSender (EmailSender):\n        ...     def send(self, msg):\n        ...         print(\"Sending message via smtp\")\n        ...\n        &gt;&gt;&gt; container.register(EmailSender, SmtpEmailSender)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; instance = container.resolve(EmailSender)\n        &gt;&gt;&gt; instance.send(\"beep\")\n        Sending message via smtp\n    \"\"\"\n    self.registrations.register(service, factory, instance, scope, **kwargs)\n    return self\n</code></pre>"},{"location":"modules/#punq.Container.resolve","title":"<code>resolve(service_key, **kwargs)</code>","text":"<p>Build and return an instance of a registered service.</p> Source code in <code>punq/__init__.py</code> <pre><code>def resolve(self, service_key, **kwargs):\n    \"\"\"Build and return an instance of a registered service.\"\"\"\n    context = self.registrations.build_context(service_key)\n\n    return self._resolve_impl(service_key, kwargs, context)\n</code></pre>"},{"location":"modules/#punq.Container.resolve_all","title":"<code>resolve_all(service, **kwargs)</code>","text":"<p>Return all registrations for a given service.</p> <p>Some patterns require us to use multiple implementations of an interface at the same time.</p> <p>Examples:</p> <p>In this example, we want to use multiple Authenticator instances to check a request.</p> <pre><code>&gt;&gt;&gt; class Authenticator:\n...     def matches(self, req):\n...         return False\n...\n...     def authenticate(self, req):\n...         return False\n...\n&gt;&gt;&gt; class BasicAuthenticator(Authenticator):\n...     def matches(self, req):\n...         head = req.headers.get(\"Authorization\", \"\")\n...         return head.startswith(\"Basic \")\n...\n&gt;&gt;&gt; class TokenAuthenticator(Authenticator):\n...     def matches(self, req):\n...         head = req.headers.get(\"Authorization\", \"\")\n...         return head.startswith(\"Bearer \")\n...\n&gt;&gt;&gt; def authenticate_request(container, req):\n...     for authn in req.resolve_all(Authenticator):\n...         if authn.matches(req):\n...             return authn.authenticate(req)\n</code></pre> Source code in <code>punq/__init__.py</code> <pre><code>def resolve_all(self, service, **kwargs):\n    \"\"\"Return all registrations for a given service.\n\n    Some patterns require us to use multiple implementations of an\n    interface at the same time.\n\n    Examples:\n        In this example, we want to use multiple Authenticator instances to\n        check a request.\n\n        &gt;&gt;&gt; class Authenticator:\n        ...     def matches(self, req):\n        ...         return False\n        ...\n        ...     def authenticate(self, req):\n        ...         return False\n        ...\n        &gt;&gt;&gt; class BasicAuthenticator(Authenticator):\n        ...     def matches(self, req):\n        ...         head = req.headers.get(\"Authorization\", \"\")\n        ...         return head.startswith(\"Basic \")\n        ...\n        &gt;&gt;&gt; class TokenAuthenticator(Authenticator):\n        ...     def matches(self, req):\n        ...         head = req.headers.get(\"Authorization\", \"\")\n        ...         return head.startswith(\"Bearer \")\n        ...\n        &gt;&gt;&gt; def authenticate_request(container, req):\n        ...     for authn in req.resolve_all(Authenticator):\n        ...         if authn.matches(req):\n        ...             return authn.authenticate(req)\n    \"\"\"\n    context = self.registrations.build_context(service)\n\n    return [self._build_impl(x, kwargs, context) for x in context.all_registrations(service)]\n</code></pre>"},{"location":"modules/#punq.InvalidForwardReferenceError","title":"<code>InvalidForwardReferenceError</code>","text":"<p>               Bases: <code>InvalidForwardReferenceException</code></p> <p>Raised when a registered service has a forward reference that can't be resolved.</p> <p>Examples:</p> <p>In this example, we register a service with a string as a type annotation. When we try to inspect the constructor for the service we fail with an InvalidForwardReferenceError</p> <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; from punq import Container\n&gt;&gt;&gt; @dataclass\n... class Client:\n...     dep: 'Dependency'\n&gt;&gt;&gt; container = Container()\n&gt;&gt;&gt; container.register(Client)\nTraceback (most recent call last):\n...\npunq.InvalidForwardReferenceError: name 'Dependency' is not defined\n</code></pre> <p>This error can be resolved by first registering a type with the name 'Dependency' in the container.</p> <pre><code>&gt;&gt;&gt; class Dependency:\n...     pass\n...\n&gt;&gt;&gt; container.register(Dependency)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; container.register(Client)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; container.resolve(Client)\nClient(dep=&lt;punq.Dependency object at 0x...&gt;)\n</code></pre> <p>Alternatively, we can register a type using the literal key 'Dependency'.</p> <pre><code>&gt;&gt;&gt; class AlternativeDependency:\n...     pass\n...\n&gt;&gt;&gt; container = Container()\n&gt;&gt;&gt; container.register('Dependency', AlternativeDependency)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; container.register(Client)\n&lt;punq.Container object at 0x...&gt;\n&gt;&gt;&gt; container.resolve(Client)\nClient(dep=&lt;punq.AlternativeDependency object at 0x...&gt;)\n</code></pre> Source code in <code>punq/__init__.py</code> <pre><code>class InvalidForwardReferenceError(InvalidForwardReferenceException):\n    \"\"\"Raised when a registered service has a forward reference that can't be resolved.\n\n    Examples:\n        In this example, we register a service with a string as a type annotation.\n        When we try to inspect the constructor for the service we fail with an\n        InvalidForwardReferenceError\n\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; from punq import Container\n        &gt;&gt;&gt; @dataclass\n        ... class Client:\n        ...     dep: 'Dependency'\n        &gt;&gt;&gt; container = Container()\n        &gt;&gt;&gt; container.register(Client)\n        Traceback (most recent call last):\n        ...\n        punq.InvalidForwardReferenceError: name 'Dependency' is not defined\n\n\n        This error can be resolved by first registering a type with the name\n        'Dependency' in the container.\n\n        &gt;&gt;&gt; class Dependency:\n        ...     pass\n        ...\n        &gt;&gt;&gt; container.register(Dependency)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; container.register(Client)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; container.resolve(Client)\n        Client(dep=&lt;punq.Dependency object at 0x...&gt;)\n\n\n        Alternatively, we can register a type using the literal key 'Dependency'.\n\n        &gt;&gt;&gt; class AlternativeDependency:\n        ...     pass\n        ...\n        &gt;&gt;&gt; container = Container()\n        &gt;&gt;&gt; container.register('Dependency', AlternativeDependency)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; container.register(Client)\n        &lt;punq.Container object at 0x...&gt;\n        &gt;&gt;&gt; container.resolve(Client)\n        Client(dep=&lt;punq.AlternativeDependency object at 0x...&gt;)\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.InvalidForwardReferenceException","title":"<code>InvalidForwardReferenceException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Deprecated alias for InvalidForwardReferenceError.</p> Source code in <code>punq/__init__.py</code> <pre><code>class InvalidForwardReferenceException(Exception):\n    \"\"\"Deprecated alias for InvalidForwardReferenceError.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.InvalidRegistrationError","title":"<code>InvalidRegistrationError</code>","text":"<p>               Bases: <code>InvalidRegistrationException</code></p> <p>Raised when a registration would result in an unresolvable service.</p> Source code in <code>punq/__init__.py</code> <pre><code>class InvalidRegistrationError(InvalidRegistrationException):\n    \"\"\"Raised when a registration would result in an unresolvable service.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.InvalidRegistrationException","title":"<code>InvalidRegistrationException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Deprecated alias for InvalidRegistrationError.</p> Source code in <code>punq/__init__.py</code> <pre><code>class InvalidRegistrationException(Exception):\n    \"\"\"Deprecated alias for InvalidRegistrationError.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.MissingDependencyError","title":"<code>MissingDependencyError</code>","text":"<p>               Bases: <code>MissingDependencyException</code></p> <p>Raised when a service, or one of its dependencies, is not registered.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import punq\n&gt;&gt;&gt; container = punq.Container()\n&gt;&gt;&gt; container.resolve(\"foo\")\nTraceback (most recent call last):\npunq.MissingDependencyError: Failed to resolve implementation for foo\n</code></pre> Source code in <code>punq/__init__.py</code> <pre><code>class MissingDependencyError(MissingDependencyException):\n    \"\"\"Raised when a service, or one of its dependencies, is not registered.\n\n    Examples:\n        &gt;&gt;&gt; import punq\n        &gt;&gt;&gt; container = punq.Container()\n        &gt;&gt;&gt; container.resolve(\"foo\")\n        Traceback (most recent call last):\n        punq.MissingDependencyError: Failed to resolve implementation for foo\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.MissingDependencyException","title":"<code>MissingDependencyException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Deprecated alias for MissingDependencyError.</p> Source code in <code>punq/__init__.py</code> <pre><code>class MissingDependencyException(Exception):\n    \"\"\"Deprecated alias for MissingDependencyError.\"\"\"\n\n    pass\n</code></pre>"},{"location":"modules/#punq.RegistrationScope","title":"<code>RegistrationScope</code>","text":"<p>Simple chained dictionary[service, list[implementation]].</p> Source code in <code>punq/__init__.py</code> <pre><code>class RegistrationScope:\n    \"\"\"\n    Simple chained dictionary[service, list[implementation]].\n    \"\"\"\n\n    def __init__(self, parent=None):\n        self.parent = parent\n        self.entries = defaultdict(list)\n\n    def child(self):\n        return RegistrationScope(self)\n\n    def append(self, key, value):\n        self.entries[key].append(value)\n\n    def __get(self, key, result):\n        if self.parent:\n            self.parent.__get(key, result)\n        for elem in self.entries[key]:\n            result.append(elem)\n        return result\n\n    def get(self, key):\n        return self.__get(key, [])\n</code></pre>"},{"location":"modules/#punq.Scope","title":"<code>Scope</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Controls the lifetime of resolved objects.</p> <p>Attributes:</p> Name Type Description <code>transient</code> <p>create a fresh instance for each <code>resolve</code> call</p> <code>singleton</code> <p>re-use a single instance for every <code>resolve</code> call</p> Source code in <code>punq/__init__.py</code> <pre><code>class Scope(Enum):\n    \"\"\"Controls the lifetime of resolved objects.\n\n    Attributes:\n        transient: create a fresh instance for each `resolve` call\n        singleton: re-use a single instance for every `resolve` call\n    \"\"\"\n\n    transient = 0\n    singleton = 1\n</code></pre>"}]}